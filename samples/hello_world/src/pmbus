#ifndef ZEPHYR_INCLUDE_DRIVERS_PMBUS_H_
#define ZEPHYR_INCLUDE_DRIVERS_PMBUS_H_

#include <zephyr/device.h>
#include <zephyr/drivers/smbus.h>
#include <zephyr/drivers/i2c.h>
#include <zephyr/kernel.h>
#include <math.h>

#ifdef __cplusplus
extern "C" {
#endif

/* PMBus standard command codes */
#define PMBUS_PAGE           0x00
#define PMBUS_PHASE          0x94
#define PMBUS_CLEAR_FAULTS   0x03

/* ======================== PAGE / PHASE ======================== */

static inline int pmbus_set_page(const struct device *dev, uint8_t addr, uint8_t page)
{
        return smbus_byte_data_write(dev, addr, PMBUS_PAGE, page);
}

static inline int pmbus_set_phase(const struct device *dev, uint8_t addr, uint8_t phase)
{
        return smbus_byte_data_write(dev, addr, PMBUS_PHASE, phase);
}

/* ======================== READ / WRITE ======================== */

static inline int pmbus_read_byte_data(const struct device *dev, uint8_t addr, uint8_t page,
                                       uint8_t reg, uint8_t *value)
{
        int ret = pmbus_set_page(dev, addr, page);
        if (ret) return ret;
        return smbus_byte_data_read(dev, addr, reg, value);
}

static inline int pmbus_write_byte_data(const struct device *dev, uint8_t addr, uint8_t page,
                                        uint8_t reg, uint8_t val)
{
        int ret = pmbus_set_page(dev, addr, page);
        if (ret) return ret;
        return smbus_byte_data_write(dev, addr, reg, val);
}

static inline int pmbus_update_byte_data(const struct device *dev, uint8_t addr, uint8_t page,
                                         uint8_t reg, uint8_t mask, uint8_t val)
{
        uint8_t orig;
        int ret = pmbus_read_byte_data(dev, addr, page, reg, &orig);
        if (ret) return ret;

        uint8_t updated = (orig & ~mask) | (val & mask);
        if (updated != orig)
                ret = pmbus_write_byte_data(dev, addr, page, reg, updated);

        return ret;
}

static inline int pmbus_read_word_data(const struct device *dev, uint8_t addr, uint8_t page,
                                       uint8_t reg, uint16_t *val)
{
        int ret = pmbus_set_page(dev, addr, page);
        if (ret) return ret;
        return smbus_word_data_read(dev, addr, reg, val);
}

static inline int pmbus_write_word_data(const struct device *dev, uint8_t addr, uint8_t page,
                                        uint8_t reg, uint16_t word)
{
        int ret = pmbus_set_page(dev, addr, page);
        if (ret) return ret;
        return smbus_word_data_write(dev, addr, reg, word);
}

/* ======================== RAW WRITE ======================== */

static inline int pmbus_write_byte(const struct device *dev, uint8_t addr,
                                   uint8_t page, uint8_t value)
{
        int ret = pmbus_set_page(dev, addr, page);
        if (ret) return ret;
        return smbus_byte_write(dev, addr, value);
}

/* ======================== FAULT HANDLING ======================== */

static inline int pmbus_clear_faults(const struct device *dev, uint8_t addr)
{
        return smbus_byte_write(dev, addr, PMBUS_CLEAR_FAULTS);
}

/* ======================== REGISTER VALIDATION ======================== */

static inline bool pmbus_check_byte_register(uint8_t reg)
{
        return reg <= 0x7F;
}

static inline bool pmbus_check_word_register(uint8_t reg)
{
        return reg >= 0x20 && reg <= 0x8F;
}

/* ======================== LINEAR11 Helpers ======================== */

static inline float pmbus_linear11_to_float(uint16_t val)
{
        int16_t raw = (int16_t)val;
        int exponent = raw >> 11;
        int mantissa = raw & 0x7FF;

        if (mantissa & 0x400)
                mantissa |= 0xF800;

        return mantissa * powf(2, exponent);
}

static inline uint16_t pmbus_float_to_linear11(float value)
{
        for (int exp = -15; exp < 16; ++exp) {
                int mant = value / powf(2, exp);
                if (mant >= -1024 && mant <= 1023) {
                        return ((exp & 0x1F) << 11) | (mant & 0x7FF);
                }
        }
        return 0;
}

#ifdef __cplusplus
}
#endif

#endif /* ZEPHYR_INCLUDE_DRIVERS_PMBUS_H_ */
                                               
